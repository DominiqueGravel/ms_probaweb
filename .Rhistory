Si
Sj
head(data[,1:10])
unique(IDi)
unique(IDj)
data_i = cbind(site,IDi,Xi,T,PP)
data_j = cbind(site,IDj,Xj,T,PP)
# Stack #
Xi = data[,7]#
Xj = data[,8]#
site = data[,1]#
T = data[,12]#
PP = data[,23]#
#
data_i = cbind(site,IDi,Xi,T,PP)#
data_j = cbind(site,IDj,Xj,T,PP)#
#
all_pres = rbind(data_i,data_j)#
site.ID = paste(all_pres[,1],all_pres[,2],sep = "-")
?key
?unique
library(data.table)#
set.seed(123)#
a <- matrix(sample(2, 120, replace = TRUE), ncol = 3)#
a <- as.data.frame(a)#
b <- as.data.table(a)#
#
# Confirm dimensionality#
dim(a) # 40  3#
dim(b) # 40  3#
#
# Unique rows using all columns#
dim(unique(a))  # 8 3#
dim(unique(b))  # 34 3#
#
# Unique rows using only a subset of columns#
dim(unique(a[,c("V1","V2")]))   # 4 2#
dim(unique(b[,list(V1,V2)]))    # 29 2
a
b
key(b)
setkey(b)#
key(b) #"V1" "V2" "V3"
setkey(b)
unique(a)
unique(b)
a
a <- matrix(sample(2, 120, replace = TRUE), ncol = 3)#
a <- as.data.frame(a)#
b <- as.data.table(a)
b
unique(a)
unique(b)
t = unique(all_pres)
pres = t
dim(t)
S = length(unique(pres[,2]))
S
222*374
86337/374
rastT = getValues(clim$bio1)
rastPP = getValues(clim$bio12)
i = 1
subdata = subset(pres,pres[,2]==IDs[i])#
    Xi = subdata[,3]#
    T = subdata[,4]#
    PP = subdata[,5]#
    T2 = T*T#
    PP2 = PP*PP
IDs = unique(pres[,2])
subdata = subset(pres,pres[,2]==IDs[i])#
    Xi = subdata[,3]#
    T = subdata[,4]#
    PP = subdata[,5]#
    T2 = T*T#
    PP2 = PP*PP
lmXi = glm(Xi ~ T+PP+T2+PP2, family = "binomial")
summary(lmXi)
length(Xi)
newE = data.frame(T = rastT, PP = rastPP, T2 = rastT^2, PP2 = rastPP^2)
predXi = predict(lmXi, type = "response", newdata = )
predXi = predict(lmXi, type = "response", newdata = newE)
predXi
# Loop around all species pairs#
expS = numeric(ncell)#
expL = numeric(ncell)
for(1 in 1:S) {#
    subdata = subset(pres,pres[,2]==IDs[i])#
    Xi = subdata[,3]#
    T = subdata[,4]#
    PP = subdata[,5]#
    T2 = T*T#
    PP2 = PP*PP#
    lmXi = glm(Xi ~ T+PP+T2+PP2, family = "binomial")#
    newE = data.frame(T = rastT, PP = rastPP, T2 = rastT^2, PP2 = rastPP^2)#
    predXi = predict(lmXi, type = "response", newdata = newE)#
    expS = expS + predXi#
}
mapT = getValues(clim$bio1)#
mapPP = getValues(clim$bio12)#
#
#############################################################
# Extract the local networks over Europe#
#############################################################
#
ncell = length(T)#
map_E = data.frame(T = mapT, PP = mapPP, T2 = mapT^2, PP2 = mapPP^2)#
#
# Loop around all species pairs#
expS = numeric(ncell)#
expL = numeric(ncell)
# Loop across all species#
S = length(unique(pres[,2]))#
IDs = unique(pres[,2])#
#
for(1 in 1:S) {#
    subdata = subset(pres,pres[,2]==IDs[i])#
    Xi = subdata[,3]#
    T = subdata[,4]#
    PP = subdata[,5]#
    T2 = T*T#
    PP2 = PP*PP#
    lmXi = glm(Xi ~ T+PP+T2+PP2, family = "binomial")#
    predXi = predict(lmXi, type = "response", newdata = map_E)#
    expS = expS + predXi#
}
S
for(i in 1:S) {#
    subdata = subset(pres,pres[,2]==IDs[i])#
    Xi = subdata[,3]#
    T = subdata[,4]#
    PP = subdata[,5]#
    T2 = T*T#
    PP2 = PP*PP#
    lmXi = glm(Xi ~ T+PP+T2+PP2, family = "binomial")#
    predXi = predict(lmXi, type = "response", newdata = map_E)#
    expS = expS + predXi#
}
hist(expS)
# Loop across all pairs of species#
for(pair in 1:np) {#
#
    data = DF_split[[pair]]#
    Xi = data$Xi#
    Xj = data$Xj#
    Xij = data$Xij#
    Lij = data$Lij#
    E = data$E  #
    i = as.numeric(as.vector(data$IDi[1]))#
    j = as.numeric(as.vector(data$IDj[1]))#
#
    # Compute the models#
    if(sum(Xij!=0)) {#
        lm_Xij = glm(Xij ~ T+PP+T2+PP2, family = "binomial", data = E)#
        expLij = sum(Lij)/sum(Xij)#
    }#
#
        else {#
            expXij = 0#
            expLij = 0#
    }#
#
    # Compute expected probabilities over the gradient#
    expXij = predict(lm_Xij, type="response", newdata=map_E)#
#
    # Compute species richness and link density#
    expL = expL + expLij*expXij#
#
    cat(pair,'\n')#
}
range(expL)
# Loop across all pairs of species#
for(pair in 1:np) {#
#
    data = DF_split[[pair]]#
    Xi = data$Xi#
    Xj = data$Xj#
    Xij = data$Xij#
    Lij = data$Lij#
    E = data$E  #
    i = as.numeric(as.vector(data$IDi[1]))#
    j = as.numeric(as.vector(data$IDj[1]))#
#
    # Compute the models#
    if(sum(Xij!=0)) {#
        lm_Xij = glm(Xij ~ T+PP+T2+PP2, family = "binomial", data = E)#
        expLij = sum(Lij)/sum(Xij)#
    }#
#
        else {#
            expXij = 0#
            expLij = 0#
    }#
#
    # Compute expected probabilities over the gradient#
    if(sum(Xij!=0)) {#
        expXij = predict(lm_Xij, type="response", newdata=map_E)#
        # Compute species richness and link density#
        expL = expL + expLij*expXij#
    }#
#
    cat(pair,'\n')#
}
write.table(cbind(expS,expL),"ms/figures/map_data.txt")#
#
#############################################################
# Plot network properties#
#############################################################
#
quartz(height = 3.5, width = 10)#
par(mfrow = c(1,3),mar = c(2,2,3,2))#
#
# Map parameters#
library("colorRamps")#
library("RColorBrewer")#
pal <-colorRampPalette(rev(brewer.pal(11,"RdYlBu"))) # Initialized Colors ramp palette, see here: http://colorbrewer2.org/#
#
# MAP 1: CO-OCCURRENCE PORBABILITY#
# Make the map#
par(xaxs="i", yaxs="i")#
plot(exteur,type="n", axes=FALSE, ann=FALSE)#
rect(xmin(exteur),ymin(exteur),xmax(exteur),ymax(exteur), col="#9CDDF1")#
rast <- raster(exteur, vals=log(expS), nrow = 276, ncol = 544)#
image(rast, add=TRUE, col=pal(100))#
plot(europe, border="grey25", lwd=1.2, add=TRUE)#
plot(wrld[2:3,], add=TRUE, col="white")#
mtext(text="Species richness",side=3,line=0.5,adj=-0.1,cex=1.25)#
#
# MAP 2: INTERACTION PROBABILITY#
# Make the map#
par(xaxs="i", yaxs="i")#
plot(exteur,type="n", axes=FALSE, ann=FALSE)#
rect(xmin(exteur),ymin(exteur),xmax(exteur),ymax(exteur), col="#9CDDF1")#
rast <- raster(exteur, vals=log(expL), nrow = 276, ncol = 544)#
image(rast, add=TRUE, col=pal(100))#
plot(europe, border="grey25", lwd=1.2, add=TRUE)#
plot(wrld[2:3,], add=TRUE, col="white")#
mtext(text="Number of interactions",side=3,line=0.5,adj=-0.1,cex=1.25)#
#
# MAP 3: NET INTERACTION PROBABILITY#
# Make the map#
par(xaxs="i", yaxs="i")#
plot(exteur,type="n", axes=FALSE, ann=FALSE)#
rect(xmin(exteur),ymin(exteur),xmax(exteur),ymax(exteur), col="#9CDDF1")#
rast <- raster(exteur, vals=expL/expS/expS, nrow = 276, ncol = 544)#
image(rast, add=TRUE, col=pal(100))#
plot(europe, border="grey25", lwd=1.2, add=TRUE)#
plot(wrld[2:3,], add=TRUE, col="white")#
mtext(text="Connectance",side=3,line=0.5,adj=-0.1,cex=1.25)
range(expS)
range(expS,na.rm=T)
C = expL/expS/expS
range(C,na.rm=T)
dev.copy2pdf(file = "ms/figures/map_connectance.pdf")
plot(map_E$T, expS)
plot(map_E$T/12, expS)
range(data$E$T)
range(map_E$T)
range(map_E$T,na.rm=TRUE)
plot(map_E$T/12, expS, xlim = c(-35/12,170/12))
plot(map_E$T/12, expS, xlim = c(-35/12,170/12))
quartz(height = 3.5, width = 10)#
par(mfrow = c(1,3),mar = c(2,2,3,2))#
#
# Map parameters#
library("colorRamps")#
library("RColorBrewer")#
pal <-colorRampPalette(rev(brewer.pal(11,"RdYlBu"))) # Initialized Colors ramp palette, see here: http://colorbrewer2.org/#
#
# MAP 1: CO-OCCURRENCE PORBABILITY#
# Make the map#
par(xaxs="i", yaxs="i")#
plot(exteur,type="n", axes=FALSE, ann=FALSE)#
rect(xmin(exteur),ymin(exteur),xmax(exteur),ymax(exteur), col="#9CDDF1")#
rast <- raster(exteur, vals=log(expS), nrow = 276, ncol = 544)#
image(rast, add=TRUE, col=pal(100))#
plot(europe, border="grey25", lwd=1.2, add=TRUE)#
plot(wrld[2:3,], add=TRUE, col="white")#
mtext(text="Species richness",side=3,line=0.5,adj=-0.1,cex=1.25)#
#
# MAP 2: INTERACTION PROBABILITY#
# Make the map#
par(xaxs="i", yaxs="i")#
plot(exteur,type="n", axes=FALSE, ann=FALSE)#
rect(xmin(exteur),ymin(exteur),xmax(exteur),ymax(exteur), col="#9CDDF1")#
rast <- raster(exteur, vals=log(expL), nrow = 276, ncol = 544)#
image(rast, add=TRUE, col=pal(100))#
plot(europe, border="grey25", lwd=1.2, add=TRUE)#
plot(wrld[2:3,], add=TRUE, col="white")#
mtext(text="Number of interactions",side=3,line=0.5,adj=-0.1,cex=1.25)#
#
# MAP 3: NET INTERACTION PROBABILITY#
# Make the map#
par(xaxs="i", yaxs="i")#
plot(exteur,type="n", axes=FALSE, ann=FALSE)#
rect(xmin(exteur),ymin(exteur),xmax(exteur),ymax(exteur), col="#9CDDF1")#
rast <- raster(exteur, vals=expL/expS/expS, nrow = 276, ncol = 544)#
image(rast, add=TRUE, col=pal(100))#
plot(europe, border="grey25", lwd=1.2, add=TRUE)#
plot(wrld[2:3,], add=TRUE, col="white")#
mtext(text="Connectance",side=3,line=0.5,adj=-0.1,cex=1.25)
pair_index
# Find the nb of links per pair#
nL  = numeric(length(DF_split))#
nX = numeric(length(DF_split))#
for(x in 1:length(DF_split)) {#
    nL[x] = sum(DF_split[[x]]$Lij)#
    nX[x] = sum(DF_split[[x]]$Xij)#
}#
cbind(nL,nX,nL/nX)[nX>20,]#
#
# Subset the data#
pair_index = which(nL == 10 & nX == 23) # 15644#
#pair_index = which(nL == 10 & nX == 26)#
#pair_index = which(nL == 21 & nX == 38)#
#pa
pairs
t = DF_split[[15644]]
str(t)
t$IDi
t$IDj
load("/Users/DGravel/Documents/Manuscripts/Inprep/ms_probaweb/analysis/data/pairs.Rdata")
pairs
pairs
t$IDi
t$IDj
pair_index = which(nL == 30 & nX == 41) # 21418#
#
for(i in 1:length(DF_split)) {#
    if(nX[i] > 20 & nL[i]>10 & nL[i]/nX[i] < 0.8 ) {#
        cat(i, " ", nL[i], " ", nX[i], '\n')#
    }#
}#
#
#14038#
#14456#
#14458#
#14476#
#14618#
#15626#
#21395#
#21415#
#21418#
data = DF_split[[pair_index]]#
data$E = data.frame(T = data$E$T/12, PP = data$E$PP/1000, T2 = data$E$T2/12^2, PP2 = data$E$PP2/1000^2)#
sum(data$Lij)#
sum(data$Xij)#
#
# Pick the model#
models_C2_L0 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L0)#
models_C2_L1 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L1)#
models_C2_L2 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L2)#
models_C0_L2 = fit_models.apply(data, selection = FALSE, funC = C0, funL = L2)#
models_C1_L2 = fit_models.apply(data, selection = FALSE, funC = C1, funL = L2)#
models_C3_L2 = fit_models.apply(data, selection = FALSE, funC = C3, funL = L2)#
#
# Compute the LL#
LL_C2_L0 = get_LL.apply(models_C2_L0,data)#
LL_C2_L1 = get_LL.apply(models_C2_L1,data)#
LL_C2_L2 = get_LL.apply(models_C2_L2,data)#
LL_C0_L2 = get_LL.apply(models_C0_L2,data)#
LL_C1_L2 = get_LL.apply(models_C1_L2,data)#
LL_C3_L2 = get_LL.apply(models_C3_L2,data)#
#
# Collect the results#
LL = c(#
    LL_C2_L0$sumLL,#
    LL_C2_L1$sumLL,#
    LL_C2_L2$sumLL,#
    LL_C0_L2$sumLL,#
    LL_C1_L2$sumLL,#
    LL_C3_L2$sumLL  #
    )#
#
npars = c(#
    LL_C2_L0$npars,#
    LL_C2_L1$npars,#
    LL_C2_L2$npars,#
    LL_C0_L2$npars,#
    LL_C1_L2$npars,#
    LL_C3_L2$npars  #
    )#
#
AIC = -2*LL + 2*npars
LL_C2_L0
# Collect the results#
LL = c(#
    LL_C2_L0[,1],#
    LL_C2_L1[,1],#
    LL_C2_L2[,1],#
    LL_C0_L2[,1],#
    LL_C1_L2[,1],#
    LL_C3_L2[,1]    #
    )#
#
npars = c(#
    LL_C2_L0[,2],#
    LL_C2_L1[,2],#
    LL_C2_L2[,2],#
    LL_C0_L2[,2],#
    LL_C1_L2[,2],#
    LL_C3_L2[,2]    #
    )#
#
AIC = -2*LL + 2*npars
# Collect the results#
LL = c(#
    LL_C2_L0[1],#
    LL_C2_L1[1],#
    LL_C2_L2[1],#
    LL_C0_L2[1],#
    LL_C1_L2[1],#
    LL_C3_L2[1] #
    )#
#
npars = c(#
    LL_C2_L0[2],#
    LL_C2_L1[2],#
    LL_C2_L2[2],#
    LL_C0_L2[2],#
    LL_C1_L2[2],#
    LL_C3_L2[2] #
    )
AIC = -2*LL + 2*npars
# Compute predicted values for each observation#
models = models_C2_L2#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=data$E)#
#
# Compute predicted values for the environmental space#
nsteps = 250#
seqE1 = seq(min(data$E$E1,na.rm=T),max(data$E$E1,na.rm=T),diff(range(data$E$E1,na.rm=T))/(nsteps-1))#
seqE2 = seq(min(data$E$E2,na.rm=T),max(data$E$E2,na.rm=T),diff(range(data$E$E2,na.rm=T))/(nsteps-1))#
#
expE = expand.grid(seqE1,seqE2)#
expE1 = expE[,1]#
expE2 = expE[,2]#
expE12 = expE1^2#
#
newE = data.frame(E1 = expE1,E2 = expE2, E3 = expE12, E4 = expE22)#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=newE)#
#
# Plot the results#
PXijmat = matrix(probs$PXij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijmat = matrix(probs$PLij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijXijmat = PXijmat*PLijmat#
PLijXijmat[PLijXijmat=="NaN"] = 0#
PLijlowmat = matrix(probs$PLijlow,nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijhighmat = matrix(probs$PLijhigh,nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijrangemat = -(PLijhighmat-PLijlowmat)+1#
#
quartz(width = 7, height = 7)#
par(mfrow = c(2,2),mar = c(5,6,2.5,1))#
#
image(seqE1,seqE2,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$E1[data$Xij==1],data$E$E2[data$Xij==1],pch = 19)#
points(data$E$E1[data$Xi==1 & data$Xij!=1],data$E$E2[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$E1[data$Xj==1 & data$Xij!=1],data$E$E2[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$E1[data$Xi==0 & data$Xj==0],data$E$E2[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$E1[data$Lij==1],data$E$E2[data$Lij==1],pch = 19)#
points(data$E$E1[data$Lij==0 & data$Xij==1],data$E$E2[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$E1[data$Lij==1],data$E$E2[data$Lij==1],pch = 19)#
points(data$E$E1[data$Lij==0 & data$Xij==1],data$E$E2[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijrangemat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
mtext(text=paste("Confidence interval"),side=3,line=0.5,adj=-0.1,cex=1.25)
# Load some functions#
source("analysis/scripts/functions/collect.R")#
source("analysis/scripts/functions/species_models.R")#
source("analysis/scripts/functions/interactions_models.R")#
source("analysis/scripts/functions/get_LL.R")#
source("analysis/scripts/functions/get_probs.R")#
source("analysis/scripts/functions/fit_models.R")#
#
# Load the data#
load("analysis/data/DF_split.Rdata")#
load("analysis/data/expand_data.Rdata")
# Compute predicted values for each observation#
models = models_C2_L2#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=data$E)
get_probs
# Compute predicted values for the environmental space#
nsteps = 250#
seqE1 = seq(min(data$E$E1,na.rm=T),max(data$E$E1,na.rm=T),diff(range(data$E$E1,na.rm=T))/(nsteps-1))#
seqE2 = seq(min(data$E$E2,na.rm=T),max(data$E$E2,na.rm=T),diff(range(data$E$E2,na.rm=T))/(nsteps-1))#
#
expE = expand.grid(seqE1,seqE2)#
expE1 = expE[,1]#
expE2 = expE[,2]#
expE12 = expE1^2#
#
newE = data.frame(E1 = expE1,E2 = expE2, E3 = expE12, E4 = expE22)#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=newE)
str(data)
names(data$E)
data$
E
# Find the nb of links per pair#
nL  = numeric(length(DF_split))#
nX = numeric(length(DF_split))#
for(x in 1:length(DF_split)) {#
    nL[x] = sum(DF_split[[x]]$Lij)#
    nX[x] = sum(DF_split[[x]]$Xij)#
}#
cbind(nL,nX,nL/nX)[nX>20,]#
#
# Subset the data#
#pair_index = which(nL == 10 & nX == 23) # 15644#
#pair_index = which(nL == 10 & nX == 26)#
#pair_index = which(nL == 21 & nX == 38)#
#pair_index = which(nL == 16 & nX == 23)#
#pair_index = which(nL == 15 & nX == 24)#
#pair_index = which(nL == 14 & nX == 25) # 15626#
pair_index = which(nL == 30 & nX == 41) # 21418#
#
for(i in 1:length(DF_split)) {#
    if(nX[i] > 20 & nL[i]>10 & nL[i]/nX[i] < 0.8 ) {#
        cat(i, " ", nL[i], " ", nX[i], '\n')#
    }#
}#
#
#14038#
#14456#
#14458#
#14476#
#14618#
#15626#
#21395#
#21415#
#21418#
data = DF_split[[pair_index]]#
data$E = data.frame(T = data$E$T/12, PP = data$E$PP/1000, T2 = data$E$T2/12^2, PP2 = data$E$PP2/1000^2)#
sum(data$Lij)#
sum(data$Xij)
# Compute predicted values for each observation#
models = models_C2_L2#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=data$E)#
#
# Compute predicted values for the environmental space#
nsteps = 250#
seqE1 = seq(min(data$E$E1,na.rm=T),max(data$E$E1,na.rm=T),diff(range(data$E$E1,na.rm=T))/(nsteps-1))#
seqE2 = seq(min(data$E$E2,na.rm=T),max(data$E$E2,na.rm=T),diff(range(data$E$E2,na.rm=T))/(nsteps-1))#
#
expE = expand.grid(seqE1,seqE2)#
expE1 = expE[,1]#
expE2 = expE[,2]#
expE12 = expE1^2#
#
newE = data.frame(E1 = expE1,E2 = expE2, E3 = expE12, E4 = expE22)#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=newE)
names(data$E)
seqE1 = seq(min(data$E$T,na.rm=T),max(data$E$T,na.rm=T),diff(range(data$E$T,na.rm=T))/(nsteps-1))
seqE2 = seq(min(data$E$PP,na.rm=T),max(data$E$PP,na.rm=T),diff(range(data$E$PP,na.rm=T))/(nsteps-1))
min(data$E$T,na.rm=T)
max(data$E$T,na.rm=T)
diff(range(data$E$T,na.rm=T))
seqT = seq(min(data$E$T,na.rm=T),max(data$E$T,na.rm=T),diff(range(data$E$T,na.rm=T))/(nsteps-1))
seqPP = seq(min(data$E$PP,na.rm=T),max(data$E$PP,na.rm=T),diff(range(data$E$PP,na.rm=T))/(nsteps-1))
expE = expand.grid(seqT,seqP)#
expE1 = expE[,1]#
expE2 = expE[,2]#
expE12 = expE1^2
expE = expand.grid(seqT,seqPP)
expE1 = expE[,1]
expE2 = expE[,2]
expE12 = expE1^2
expT = expE[,1]
expPP = expE[,2]
expT2 = expT^2
expPP2 = expPP^2
newE = data.frame(T = expT,T2 = expT2, PP = expPP, PP2 = expPP2)
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=newE)
# Plot the results#
PXijmat = matrix(probs$PXij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijmat = matrix(probs$PLij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijXijmat = PXijmat*PLijmat#
PLijXijmat[PLijXijmat=="NaN"] = 0#
PLijlowmat = matrix(probs$PLijlow,nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijhighmat = matrix(probs$PLijhigh,nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijrangemat = -(PLijhighmat-PLijlowmat)+1
nsteps
PXijmat = matrix(probs$PXij, nr = nsteps, nc = nsteps, byrow = FALSE)
PLijmat = matrix(probs$PLij, nr = nsteps, nc = nsteps, byrow = FALSE)
PLijXijmat = PXijmat*PLijmat
PLijXijmat[PLijXijmat=="NaN"] = 0
PLijlowmat = matrix(probs$PLijlow,nr = nsteps, nc = nsteps, byrow = FALSE)
str(probs)
quartz(height = 3.5, width = 10)#
par(mfrow = c(1,3),mar = c(2,2,3,2))#
image(seqE1,seqE2,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$E1[data$Xij==1],data$E$E2[data$Xij==1],pch = 19)#
points(data$E$E1[data$Xi==1 & data$Xij!=1],data$E$E2[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$E1[data$Xj==1 & data$Xij!=1],data$E$E2[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$E1[data$Xi==0 & data$Xj==0],data$E$E2[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$E1[data$Lij==1],data$E$E2[data$Lij==1],pch = 19)#
points(data$E$E1[data$Lij==0 & data$Xij==1],data$E$E2[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$E1[data$Lij==1],data$E$E2[data$Lij==1],pch = 19)#
points(data$E$E1[data$Lij==0 & data$Xij==1],data$E$E2[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)
image(seqE1,seqE2,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Xij==1],data$E$PP[data$Xij==1],pch = 19)#
points(data$E$T[data$Xi==1 & data$Xij!=1],data$E$PP[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$T[data$Xj==1 & data$Xij!=1],data$E$PP[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$T[data$Xi==0 & data$Xj==0],data$E$PP[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)
image(seqE1,seqE2,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)
par(mfrow = c(1,3),mar = c(5,6,2.5,1))
image(seqE1,seqE2,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Xij==1],data$E$PP[data$Xij==1],pch = 19)#
points(data$E$T[data$Xi==1 & data$Xij!=1],data$E$PP[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$T[data$Xj==1 & data$Xij!=1],data$E$PP[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$T[data$Xi==0 & data$Xj==0],data$E$PP[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)
pair_index
data$IDi
data$IDj
30/41
# Pick the model#
models_C2_L0 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L0)#
models_C2_L1 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L1)#
models_C2_L2 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L2)#
models_C0_L2 = fit_models.apply(data, selection = FALSE, funC = C0, funL = L2)#
models_C1_L2 = fit_models.apply(data, selection = FALSE, funC = C1, funL = L2)#
models_C3_L2 = fit_models.apply(data, selection = FALSE, funC = C3, funL = L2)#
#
# Compute the LL#
LL_C2_L0 = get_LL.apply(models_C2_L0,data)#
LL_C2_L1 = get_LL.apply(models_C2_L1,data)#
LL_C2_L2 = get_LL.apply(models_C2_L2,data)#
LL_C0_L2 = get_LL.apply(models_C0_L2,data)#
LL_C1_L2 = get_LL.apply(models_C1_L2,data)#
LL_C3_L2 = get_LL.apply(models_C3_L2,data)#
#
# Collect the results#
LL = c(#
    LL_C2_L0[1],#
    LL_C2_L1[1],#
    LL_C2_L2[1],#
    LL_C0_L2[1],#
    LL_C1_L2[1],#
    LL_C3_L2[1] #
    )#
#
npars = c(#
    LL_C2_L0[2],#
    LL_C2_L1[2],#
    LL_C2_L2[2],#
    LL_C0_L2[2],#
    LL_C1_L2[2],#
    LL_C3_L2[2] #
    )#
#
AIC = -2*LL + 2*npars#
#
# Write the results in a table#
write.table(cbind(LL,npars,AIC), file = "ms/figures/table1.txt")
cbind(LL,npars,AIC)
nL
test = numeric(length(DF_split))
t1 = test
t1[nL!=0] = 1
sum(t1)
t1[nL!=0 & nL == nX] = 1
t1 = test
t1[nL!=0 & nL == nX] = 1
sum(t1)
cbind(nL,nX)[t1==1,]
t1[nL>1 & nL == nX] = 1
t1 = test
t1[nL>1 & nL == nX] = 1
sum(t1)
t1[nL>5 & nL == nX] = 1
t1 = test
t1[nL>5 & nL == nX] = 1
sum(t1)
t1 = test
t1[nL==1 & nX == 1] = 1
sum(t1)
t1[nL>5]=1
t1 = test
t1[nL>5]=1
sum(t1)
length(DF_split)
1077/32412
t = numeric(32412)
t[nX!=0]
t[nX!=0]=1
sum(t)
32412-8437
23975/32412
1077/8437
# Load the data#
load("analysis/data/expand_data.Rdata")#
load("analysis/data/DF_split.Rdata")#
load("analysis/data/pairs.Rdata")#
#
IDi = as.character(data$pairs.IDi)#
IDj = as.character(data$pairs.IDj)#
Si = length(unique(IDi))#
Sj = length(unique(IDj))#
unique_IDi = unique(IDi)#
unique_IDj = unique(IDj)#
IDcomm = IDj[match(unique_IDi,unique_IDj,nomatch=0)]#
unique_ID_all = unique(c(IDi,IDj))#
Sall = length(unique_ID_all)#
DF = data.frame(sites = data$pairs.sites_ID, IDi = IDi, IDj = IDj, Xi=data$Xi, Xj=data$Xj, Xij = data$Xij, Lij = data$Lij)#
#
##########################################################
# Network sampling#
##########################################################
#
# Adjacency matrix for the metaweb#
# Loop around all pairs of species to test if there are interactions#
# Put everything in a square matrix#
mw = data.frame(matrix(0, nr = Sall, nc = Sall))#
names(mw) = unique_ID_all#
row.names(mw) = unique_ID_all#
#
n = 1#
for(i in 1:Si) {#
    for(j in 1:Sj) {#
#
        # Compute the number of links#
        nL = sum(DF_split[[n]]$Lij)#
#
        if(nL!=0) {#
#
            # Get the victim#
            index_i = which(unique_ID_all == as.character(DF_split[[n]]$IDi)[1])#
#
            # Get the ennemy index#
            index_j = which(unique_ID_all == as.character(DF_split[[n]]$IDj)[1])#
#
            # Put the record in the mw#
            mw[index_i,index_j] = 1#
            mw[index_j,index_i] = 1#
        }#
        n = n+1#
    }#
}#
#
##########################################
# Compute the local network for one site#
lw = matrix(0, nr = Sall, nc = Sall)#
DF_split_sites = split(DF,DF$sites)#
site_index = 369 # Pick one that has a decent number of links#
#
n = 1#
for(i in 1:Si) {#
    for(j in 1:Sj) {#
#
        # Compute the number of links#
        nL = DF_split_sites[[site_index]]$Lij[n]#
#
        if(nL!=0) {#
#
            # Get the victim#
            index_i = which(unique_ID_all == as.character(DF_split_sites[[site_index]]$IDi[n]))#
#
            # Get the ennemy index#
            index_j = which(unique_ID_all == as.character(DF_split_sites[[site_index]]$IDj[n]))#
#
            # Put the record in the mw#
            lw[index_i,index_j] = 1#
            lw[index_j,index_i] = 1#
        }#
        n = n+1#
    }#
}#
#
##########################################################
# Convert the metaweb to igraph#
##########################################################
#
library(igraph)#
g = graph.incidence(mw,add.names=NULL)#
#
##########################################################
# Set the layer attribute for every node#
##########################################################
#
salix_ID = as.character(unique(pairs[pairs$type=="SG",1]))#
gall_ID = as.character(unique(pairs[pairs$type=="GP",1]))#
par_ID = as.character(unique(pairs[pairs$type=="GP",2]))#
#
V(g)$layer[V(g)$name %in% salix_ID] = 1#
V(g)$layer[V(g)$name %in% gall_ID] = 2#
V(g)$layer[V(g)$name %in% par_ID] = 3#
#
##########################################################
# Plot the metaweb#
##########################################################
#
quartz(width = 5, height = 25)#
#
# Function to set the layout#
layout.k_partite <- function(g) {#
  l <- layout.sugiyama(g)$layout[,2:1]#
  l[,1] <- V(g)$layer#
  l[,2] <- - l[,2] + 1 + max(l[,2])#
  l#
}#
#
# Color code the nodes that are present#
dlw = apply(lw,1,sum)#
V(g)$color[V(g)$name %in% salix_ID] = "darkgreen"#
V(g)$color[V(g)$name %in% gall_ID] = "darkred"#
V(g)$color[V(g)$name %in% par_ID] = "darkblue"#
V(g)$color[dlw==0] = "white"#
V(g)$size = 2#
V(g)$size[dlw!=0] = 4#
#
# Plot the network#
#
plot(g, layout = layout.k_partite(g),vertex.label=NA,edge.arrow.mode=0,edge.width=0.3,margin = c(-0.1,-0.1,-0.1,-0.1),asp=0)
# Load the data#
load("analysis/data/expand_data.Rdata")#
load("analysis/data/DF_split.Rdata")#
load("analysis/data/pairs.Rdata")#
#
IDi = as.character(data$pairs.IDi)#
IDj = as.character(data$pairs.IDj)#
Si = length(unique(IDi))#
Sj = length(unique(IDj))#
unique_IDi = unique(IDi)#
unique_IDj = unique(IDj)#
IDcomm = IDj[match(unique_IDi,unique_IDj,nomatch=0)]#
unique_ID_all = unique(c(IDi,IDj))#
Sall = length(unique_ID_all)#
DF = data.frame(sites = data$pairs.sites_ID, IDi = IDi, IDj = IDj, Xi=data$Xi, Xj=data$Xj, Xij = data$Xij, Lij = data$Lij)#
#
##########################################################
# Network sampling#
##########################################################
#
# Adjacency matrix for the metaweb#
# Loop around all pairs of species to test if there are interactions#
# Put everything in a square matrix#
mw = data.frame(matrix(0, nr = Sall, nc = Sall))#
names(mw) = unique_ID_all#
row.names(mw) = unique_ID_all#
#
n = 1#
for(i in 1:Si) {#
    for(j in 1:Sj) {#
#
        # Compute the number of links#
        nL = sum(DF_split[[n]]$Lij)#
#
        if(nL!=0) {#
#
            # Get the victim#
            index_i = which(unique_ID_all == as.character(DF_split[[n]]$IDi)[1])#
#
            # Get the ennemy index#
            index_j = which(unique_ID_all == as.character(DF_split[[n]]$IDj)[1])#
#
            # Put the record in the mw#
            mw[index_i,index_j] = 1#
            mw[index_j,index_i] = 1#
        }#
        n = n+1#
    }#
}#
#
##########################################
# Compute the local network for one site#
lw = matrix(0, nr = Sall, nc = Sall)#
DF_split_sites = split(DF,DF$sites)#
site_index = 369 # Pick one that has a decent number of links#
#
n = 1#
for(i in 1:Si) {#
    for(j in 1:Sj) {#
#
        # Compute the number of links#
        nL = DF_split_sites[[site_index]]$Lij[n]#
#
        if(nL!=0) {#
#
            # Get the victim#
            index_i = which(unique_ID_all == as.character(DF_split_sites[[site_index]]$IDi[n]))#
#
            # Get the ennemy index#
            index_j = which(unique_ID_all == as.character(DF_split_sites[[site_index]]$IDj[n]))#
#
            # Put the record in the mw#
            lw[index_i,index_j] = 1#
            lw[index_j,index_i] = 1#
        }#
        n = n+1#
    }#
}#
#
##########################################################
# Convert the metaweb to igraph#
##########################################################
#
library(igraph)#
g = graph.incidence(mw,add.names=NULL)#
#
##########################################################
# Set the layer attribute for every node#
##########################################################
#
salix_ID = as.character(unique(pairs[pairs$type=="SG",1]))#
gall_ID = as.character(unique(pairs[pairs$type=="GP",1]))#
par_ID = as.character(unique(pairs[pairs$type=="GP",2]))#
#
V(g)$layer[V(g)$name %in% salix_ID] = 1#
V(g)$layer[V(g)$name %in% gall_ID] = 2#
V(g)$layer[V(g)$name %in% par_ID] = 3#
#
##########################################################
# Plot the metaweb#
##########################################################
#
quartz(width = 5, height = 25)#
#
# Function to set the layout#
layout.k_partite <- function(g) {#
  l <- layout.sugiyama(g)$layout[,2:1]#
  l[,1] <- V(g)$layer#
  l[,2] <- - l[,2] + 1 + max(l[,2])#
  l#
}#
#
# Color code the nodes that are present#
dlw = apply(lw,1,sum)#
V(g)$color[V(g)$name %in% salix_ID] = "darkgreen"#
V(g)$color[V(g)$name %in% gall_ID] = "darkred"#
V(g)$color[V(g)$name %in% par_ID] = "darkblue"#
V(g)$color[dlw==0] = "white"#
V(g)$size = 2#
V(g)$size[dlw!=0] = 4#
#
# Plot the network#
#
plot(g, layout = layout.k_partite(g),vertex.label=NA,edge.arrow.mode=0,edge.width=0.3,margin = c(-0.1,-0.1,-0.1,-0.1),asp=0)
quartz(height = 3.5, width = 10)#
par(mfrow = c(1,3),mar = c(5,6,2.5,1))#
#
image(seqE1,seqE2,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Xij==1],data$E$PP[data$Xij==1],pch = 19)#
points(data$E$T[data$Xi==1 & data$Xij!=1],data$E$PP[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$T[data$Xj==1 & data$Xij!=1],data$E$PP[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$T[data$Xi==0 & data$Xj==0],data$E$PP[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
#image(seqE1,seqE2,1-PLijrangemat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
#mtext(text=paste("Confidence interval"),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
dev.copy2pdf(file = "ms/figures/example_pair.pdf")
quartz(width = 5, height = 25)
quartz(width = 5, height = 10)
# Function to set the layout#
layout.k_partite <- function(g) {#
  l <- layout.sugiyama(g)$layout[,2:1]#
  l[,1] <- V(g)$layer#
  l[,2] <- - l[,2] + 1 + max(l[,2])#
  l#
}#
#
# Color code the nodes that are present#
dlw = apply(lw,1,sum)#
V(g)$color[V(g)$name %in% salix_ID] = "darkgreen"#
V(g)$color[V(g)$name %in% gall_ID] = "darkred"#
V(g)$color[V(g)$name %in% par_ID] = "darkblue"#
V(g)$color[dlw==0] = "white"#
V(g)$size = 2#
V(g)$size[dlw!=0] = 4#
#
# Plot the network#
#
plot(g, layout = layout.k_partite(g),vertex.label=NA,edge.arrow.mode=0,edge.width=0.3,margin = c(-0.1,-0.1,-0.1,-0.1),asp=0)
quartz(width = 5, height = 8)
quartz(width = 5, height = 7)
quartz(width = 5, height = 7)
quartz(width = 5, height = 6)
quartz(width = 5, height = 7)
# Function to set the layout#
layout.k_partite <- function(g) {#
  l <- layout.sugiyama(g)$layout[,2:1]#
  l[,1] <- V(g)$layer#
  l[,2] <- - l[,2] + 1 + max(l[,2])#
  l#
}#
#
# Color code the nodes that are present#
dlw = apply(lw,1,sum)#
V(g)$color[V(g)$name %in% salix_ID] = "darkgreen"#
V(g)$color[V(g)$name %in% gall_ID] = "darkred"#
V(g)$color[V(g)$name %in% par_ID] = "darkblue"#
V(g)$color[dlw==0] = "white"#
V(g)$size = 2#
V(g)$size[dlw!=0] = 4#
#
# Plot the network#
#
plot(g, layout = layout.k_partite(g),vertex.label=NA,edge.arrow.mode=0,edge.width=0.3,margin = c(-0.1,-0.1,-0.1,-0.1),asp=0)
plot(g, layout = layout.k_partite(g),vertex.label=NA,edge.arrow.mode=0,edge.width=0.3,margin = c(-0.05,-0.1,-0.1,-0.1),asp=0)
plot(g, layout = layout.k_partite(g),vertex.label=NA,edge.arrow.mode=0,edge.width=0.3,margin = c(-0.075,-0.1,-0.075,-0.1),asp=0)
dev.copy2pdf(file = "ms/figures/metaweb_sampling.pdf")
###################################################################
# Script for Figure X,#
# Illustrating the computation of interaction probabilities for a #
# pair of species#
# Dominique Gravel#
# October 29th, 2015#
###################################################################
#
rm(list = ls())#
#
# Load some functions#
source("analysis/scripts/functions/collect.R")#
source("analysis/scripts/functions/species_models.R")#
source("analysis/scripts/functions/interactions_models.R")#
source("analysis/scripts/functions/get_LL.R")#
source("analysis/scripts/functions/get_probs.R")#
source("analysis/scripts/functions/fit_models.R")#
#
# Load the data#
load("analysis/data/DF_split.Rdata")#
load("analysis/data/expand_data.Rdata")#
#
##########################################################
# Fit the different models#
##########################################################
#
# Find the nb of links per pair#
nL  = numeric(length(DF_split))#
nX = numeric(length(DF_split))#
for(x in 1:length(DF_split)) {#
    nL[x] = sum(DF_split[[x]]$Lij)#
    nX[x] = sum(DF_split[[x]]$Xij)#
}#
cbind(nL,nX,nL/nX)[nX>20,]#
#
# Subset the data#
#pair_index = which(nL == 10 & nX == 23) # 15644#
#pair_index = which(nL == 10 & nX == 26)#
#pair_index = which(nL == 21 & nX == 38)#
#pair_index = which(nL == 16 & nX == 23)#
#pair_index = which(nL == 15 & nX == 24)#
#pair_index = which(nL == 14 & nX == 25) # 15626#
pair_index = which(nL == 30 & nX == 41) # 21418#
#
for(i in 1:length(DF_split)) {#
    if(nX[i] > 20 & nL[i]>10 & nL[i]/nX[i] < 0.8 ) {#
        cat(i, " ", nL[i], " ", nX[i], '\n')#
    }#
}#
#
#14038#
#14456#
#14458#
#14476#
#14618#
#15626#
#21395#
#21415#
#21418#
data = DF_split[[pair_index]]#
data$E = data.frame(T = data$E$T/12, PP = data$E$PP/1000, T2 = data$E$T2/12^2, PP2 = data$E$PP2/1000^2)#
sum(data$Lij)#
sum(data$Xij)#
#
# Pick the model#
models_C2_L0 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L0)#
models_C2_L1 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L1)#
models_C2_L2 = fit_models.apply(data, selection = FALSE, funC = C2, funL = L2)#
models_C0_L2 = fit_models.apply(data, selection = FALSE, funC = C0, funL = L2)#
models_C1_L2 = fit_models.apply(data, selection = FALSE, funC = C1, funL = L2)#
models_C3_L2 = fit_models.apply(data, selection = FALSE, funC = C3, funL = L2)#
#
# Compute the LL#
LL_C2_L0 = get_LL.apply(models_C2_L0,data)#
LL_C2_L1 = get_LL.apply(models_C2_L1,data)#
LL_C2_L2 = get_LL.apply(models_C2_L2,data)#
LL_C0_L2 = get_LL.apply(models_C0_L2,data)#
LL_C1_L2 = get_LL.apply(models_C1_L2,data)#
LL_C3_L2 = get_LL.apply(models_C3_L2,data)#
#
# Collect the results#
LL = c(#
    LL_C2_L0[1],#
    LL_C2_L1[1],#
    LL_C2_L2[1],#
    LL_C0_L2[1],#
    LL_C1_L2[1],#
    LL_C3_L2[1] #
    )#
#
npars = c(#
    LL_C2_L0[2],#
    LL_C2_L1[2],#
    LL_C2_L2[2],#
    LL_C0_L2[2],#
    LL_C1_L2[2],#
    LL_C3_L2[2] #
    )#
#
AIC = -2*LL + 2*npars#
#
# Write the results in a table#
write.table(cbind(LL,npars,AIC), file = "ms/figures/table1.txt") #
##########################################################
# Plot the results#
##########################################################
#
# Compute predicted values for each observation#
models = models_C2_L2#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=data$E)#
#
# Compute predicted values for the environmental space#
nsteps = 250#
seqT = seq(min(data$E$T,na.rm=T),max(data$E$T,na.rm=T),diff(range(data$E$T,na.rm=T))/(nsteps-1))#
seqPP = seq(min(data$E$PP,na.rm=T),max(data$E$PP,na.rm=T),diff(range(data$E$PP,na.rm=T))/(nsteps-1))#
#
expE = expand.grid(seqT,seqPP)#
expT = expE[,1]#
expPP = expE[,2]#
expT2 = expT^2#
expPP2 = expPP^2#
#
newE = data.frame(T = expT,T2 = expT2, PP = expPP, PP2 = expPP2)#
probs = get_probs(modelC=models$modelC, modelL=models$modelL, newE=newE)#
#
# Plot the results#
PXijmat = matrix(probs$PXij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijmat = matrix(probs$PLij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijXijmat = PXijmat*PLijmat#
PLijXijmat[PLijXijmat=="NaN"] = 0#
PLijlowmat = matrix(probs$PLijlow,nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijhighmat = matrix(probs$PLijhigh,nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijrangemat = -(PLijhighmat-PLijlowmat)+1#
#
#quartz(width = 7, height = 7)#
#par(mfrow = c(2,2),mar = c(5,6,2.5,1))#
#
quartz(height = 3.5, width = 10)#
par(mfrow = c(1,3),mar = c(5,6,2.5,1))#
#
image(seqE1,seqE2,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Xij==1],data$E$PP[data$Xij==1],pch = 19)#
points(data$E$T[data$Xi==1 & data$Xij!=1],data$E$PP[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$T[data$Xj==1 & data$Xij!=1],data$E$PP[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$T[data$Xi==0 & data$Xj==0],data$E$PP[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqE1,seqE2,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
#image(seqE1,seqE2,1-PLijrangemat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
#mtext(text=paste("Confidence interval"),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
dev.copy2pdf(file = "ms/figures/example_pair.pdf")
# Plot the results#
PXijmat = matrix(probs$PXij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijmat = matrix(probs$PLij, nr = nsteps, nc = nsteps, byrow = FALSE)#
PLijXijmat = PXijmat*PLijmat#
PLijXijmat[PLijXijmat=="NaN"] = 0#
#
quartz(height = 3.5, width = 10)#
par(mfrow = c(1,3),mar = c(5,6,2.5,1))#
#
image(seqT,seqPP,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Xij==1],data$E$PP[data$Xij==1],pch = 19)#
points(data$E$T[data$Xi==1 & data$Xij!=1],data$E$PP[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$T[data$Xj==1 & data$Xij!=1],data$E$PP[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$T[data$Xi==0 & data$Xj==0],data$E$PP[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqT,seqPP,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqT,seqPP,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqE1),ylim = 1.05*range(seqE2))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)
image(seqT,seqPP,1-PXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.3,1,1/1000)),xlim = 1.05*range(seqT),ylim = 1.05*range(seqPP))
points(data$E$T[data$Xij==1],data$E$PP[data$Xij==1],pch = 19)#
points(data$E$T[data$Xi==1 & data$Xij!=1],data$E$PP[data$Xi==1 & data$Xij!=1],pch = 3)#
points(data$E$T[data$Xj==1 & data$Xij!=1],data$E$PP[data$Xj==1 & data$Xij!=1],pch = 8)#
points(data$E$T[data$Xi==0 & data$Xj==0],data$E$PP[data$Xi==0 & data$Xj==0],pch = 1)#
mtext(text=expression(P(X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqT,seqPP,1-PLijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqT),ylim = 1.05*range(seqPP))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij])),side=3,line=0.5,adj=-0.1,cex=1.25)#
#
image(seqT,seqPP,1-PLijXijmat, xlab = "Annual mean temperature",ylab = "Annual precipitation",cex.axis = 1.25, cex.lab = 1.5, col = gray(seq(0.5,1,1/1000)),xlim = 1.05*range(seqT),ylim = 1.05*range(seqPP))#
points(data$E$T[data$Lij==1],data$E$PP[data$Lij==1],pch = 19)#
points(data$E$T[data$Lij==0 & data$Xij==1],data$E$PP[data$Lij==0 & data$Xij==1],pch = 1)#
mtext(text=expression(P(L[ij],X[i],X[j])),side=3,line=0.5,adj=-0.1,cex=1.25)
dev.copy2pdf(file = "ms/figures/example_pair.pdf")
getwd()
IDi = as.character(data$pairs.IDi)#
IDj = as.character(data$pairs.IDj)#
Si = length(unique(IDi))#
Sj = length(unique(IDj))#
unique_IDi = unique(IDi)#
unique_IDj = unique(IDj)#
IDcomm = IDj[match(unique_IDi,unique_IDj,nomatch=0)]#
unique_ID_all = unique(c(IDi,IDj))#
Sall = length(unique_ID_all)#
DF = data.frame(sites = data$pairs.sites_ID, IDi = IDi, IDj = IDj, Xi=data$Xi, Xj=data$Xj, Xij = data$Xij, Lij = data$Lij)
rm(list = ls())#
setwd("/Users/DGravel/Documents/Manuscripts/Inprep/ms_probaweb")#
load("data/DF_split.Rdata")#
load("data/expand_data.Rdata")#
#
IDi = as.character(data$pairs.IDi)#
IDj = as.character(data$pairs.IDj)#
Si = length(unique(IDi))#
Sj = length(unique(IDj))#
unique_IDi = unique(IDi)#
unique_IDj = unique(IDj)#
IDcomm = IDj[match(unique_IDi,unique_IDj,nomatch=0)]#
unique_ID_all = unique(c(IDi,IDj))#
Sall = length(unique_ID_all)#
DF = data.frame(sites = data$pairs.sites_ID, IDi = IDi, IDj = IDj, Xi=data$Xi, Xj=data$Xj, Xij = data$Xij, Lij = data$Lij)
getwd()
load("analysis/data/DF_split.Rdata")
load("analysis/data/expand_data.Rdata")#
#
IDi = as.character(data$pairs.IDi)#
IDj = as.character(data$pairs.IDj)#
Si = length(unique(IDi))#
Sj = length(unique(IDj))#
unique_IDi = unique(IDi)#
unique_IDj = unique(IDj)#
IDcomm = IDj[match(unique_IDi,unique_IDj,nomatch=0)]#
unique_ID_all = unique(c(IDi,IDj))#
Sall = length(unique_ID_all)#
DF = data.frame(sites = data$pairs.sites_ID, IDi = IDi, IDj = IDj, Xi=data$Xi, Xj=data$Xj, Xij = data$Xij, Lij = data$Lij)
Lij= matrix(0, nr = Sall, nc = Sall)#
Xij = matrix(0, nr = Sall, nc = Sall)#
#
n = 1#
for(i in 1:Si) {#
    for(j in 1:Sj) {#
#
        # Compute the number of links#
        nL = sum(DF_split[[n]]$Lij)#
#
        # Compute the number of co-occurrences#
        nX = sum(DF_split[[n]]$Xij)#
#
        if(nX!=0) {#
#
            # Get the victim#
            index_i = which(unique_ID_all == as.character(DF_split[[n]]$IDi)[1])#
#
            # Get the ennemy index#
            index_j = which(unique_ID_all == as.character(DF_split[[n]]$IDj)[1])#
#
            # Put the record in the mw#
            Lij[index_i,index_j] = nL#
            Xij[index_i,index_j] = nX#
        }#
        n = n+1#
    }#
}#
#
# Subset the two matrices to have an Si X Sj matrix#
subPL = PL[match(unique_IDi,unique_ID_all),match(unique_IDj,unique_ID_all)]#
subPLrange = PLrange[match(unique_IDi,unique_ID_all),match(unique_IDj,unique_ID_all)]#
NAs = is.na(subPL)#
subPL[NAs]=0#
#
# Sort the matrix by generality#
di = apply(subPL,1,sum,na.rm=TRUE)#
dj = apply(subPL,2,sum,na.rm=TRUE)#
subPL = subPL[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
#
# Flip the matrices to have ennemies in colums and victims in rows#
subPLrange = subPLrange[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
NAs = NAs[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
subPL = t(subPL)#
subPLrange = t(subPLrange)#
NAs = t(NAs)
# Subset the two matrices to have an Si X Sj matrix#
PL = Lij/Xij#
subPL = PL[match(unique_IDi,unique_ID_all),match(unique_IDj,unique_ID_all)]#
subPLrange = PLrange[match(unique_IDi,unique_ID_all),match(unique_IDj,unique_ID_all)]#
#
NAs = is.na(subPL)#
subPL[NAs]=0#
#
# Sort the matrix by generality#
di = apply(subPL,1,sum,na.rm=TRUE)#
dj = apply(subPL,2,sum,na.rm=TRUE)#
subPL = subPL[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
#
# Flip the matrices to have ennemies in colums and victims in rows#
subPLrange = subPLrange[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
NAs = NAs[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
subPL = t(subPL)#
subPLrange = t(subPLrange)#
NAs = t(NAs)
# Subset the two matrices to have an Si X Sj matrix#
PL = Lij/Xij#
subPL = PL[match(unique_IDi,unique_ID_all),match(unique_IDj,unique_ID_all)]#
NAs = is.na(subPL)#
subPL[NAs]=0
# Sort the matrix by generality#
di = apply(subPL,1,sum,na.rm=TRUE)#
dj = apply(subPL,2,sum,na.rm=TRUE)#
subPL = subPL[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]
NAs = NAs[order(di,decreasing = FALSE), order(dj, decreasing = TRUE)]#
subPL = t(subPL)#
NAs = t(NAs)
quartz(width = 8, height = 4)#
par(mfrow = c(1,2),mar = c(5,6,2,1))#
#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim", cex.axis = 1.25, cex.lab = 1.5)#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "Victim", cex.axis = 1.25, cex.lab = 1.5)
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim", cex.axis = 1., cex.lab = 1.25)
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "Victim", cex.axis = 1.25, cex.lab = 1.5)
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "Victim", cex.axis = 1, cex.lab = 1.25)
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim", cex.axis = 1., cex.lab = 1.25)#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "Victim", cex.axis = 1, cex.lab = 1.25)
quartz(width = 8, height = 4)#
par(mfrow = c(1,2),mar = c(5,6,2,1))#
#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim", cex.axis = 1., cex.lab = 1.25)#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "Victim", cex.axis = 1, cex.lab = 1.25)
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim", cex.axis = 1., cex.lab = 1.25,xaxt="")
?plot
?axis
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim", cex.axis = 1., cex.lab = 1.25,axes = FALSE)
?par
quartz(width = 8, height = 4)#
#
par(mfrow = c(1,2),mar = c(5,6,2,0))#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim",  cex.lab = 1.25,axes = FALSE)#
#
par(mar = c(5,1,2,5))#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "", cex.lab = 1.25,axes = FALSE)
?axes
?axis
box()
par(mfrow = c(1,2),mar = c(5,6,2,0))#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim",  cex.lab = 1.25,axes = FALSE)#
box()#
par(mar = c(5,1,2,5))#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "Ennemy", ylab = "", cex.lab = 1.25,axes = FALSE)#
box()
?axis
?mtext
par(mfrow = c(1,2),mar = c(5,6,2,0))
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "Ennemy", ylab = "Victim",  cex.lab = 1.25,axes = FALSE)
box()
mtext("Ennemy",side = 3, cex = 1.25)
mtext("Victim",side = 2, cex = 1.25)
par(mfrow = c(1,2),mar = c(1,3,2,0))
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "", ylab = "",  cex.lab = 1.25,axes = FALSE)
box()
mtext("Ennemy",side = 3, cex = 1.25)
mtext("Victim",side = 2, cex = 1.25)
par(mar = c(2,1,2,2))
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "", ylab = "", cex.lab = 1.25,axes = FALSE)
box()
mtext("Ennemy",side = 3, cex = 1.25)
par(mfrow = c(1,2),mar = c(2,3,2,0))#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "", ylab = "",  cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25)#
mtext("Victim",side = 2, cex = 1.25)#
par(mar = c(2,1,2,2))#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "", ylab = "", cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25)
par(mfrow = c(1,2),mar = c(2,3,2,0))
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "", ylab = "",  cex.lab = 1.25,axes = FALSE)
box()
mtext("Ennemy",side = 3, cex = 1.25)
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)
mtext("Victim",side = 2, cex = 1.25, line = 0.5)
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)
par(mfrow = c(1,2),mar = c(2,3,2,0))#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "", ylab = "",  cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)#
mtext("Victim",side = 2, cex = 1.25, line = 0.5)#
par(mar = c(2,1,2,2))#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "", ylab = "", cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)
par(mfrow = c(1,2),mar = c(2,3,2,0))#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "", ylab = "",  cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)#
mtext("Victim",side = 2, cex = 1.25, line = 0.5)#
par(mar = c(2,0,2,3))#
image(c(1:Sj),c(1:Si),NAs,col = c("white","red"),xlab = "", ylab = "", cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)#
mtext("Victim",side = 4, cex = 1.25, line = 0.5)
dev.copy2pdf(file = "ms/figures/mw_holes.pdf")
par(mfrow = c(1,2),mar = c(2,3,2,0))#
image(c(1:Sj),c(1:Si),subPL,col = rev(gray(seq(0,1,1/1000))),xlab = "", ylab = "",  cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)#
mtext("Victim",side = 2, cex = 1.25, line = 0.5)#
par(mar = c(2,0,2,3))#
image(c(1:Sj),c(1:Si),NAs,col = c("white","black"),xlab = "", ylab = "", cex.lab = 1.25,axes = FALSE)#
box()#
mtext("Ennemy",side = 3, cex = 1.25, line = 0.5)#
mtext("Victim",side = 4, cex = 1.25, line = 0.5)
dev.copy2pdf(file = "ms/figures/mw_holes.pdf")
library(rootSolve)#
rm(list = ls())#
#
# Create a random metapop structure#
n = 100#
r = 0.1#
XY = cbind(runif(n), runif(n))#
A = rexp(n = n, rate = 1)#
#
distMat = as.matrix(dist(XY, method = 'euclidean', upper = T, diag = T))#
adjMat = matrix(0, nr = n, nc = n)#
adjMat[distMat < r] = 1#
diag(adjMat) = 0#
#
# Plot the random metapop#
x11(height = 5.5, width = 6)#
par(mar=c(5,6,2,1))#
plot(XY[,1],XY[,2],xlab = "X", ylab = "Y",cex.lab = 1.5, cex.axis = 1.25,cex = A, pch = 19)#
adjVec = stack(as.data.frame(adjMat))[,1]#
XX = expand.grid(XY[,1],XY[,1])#
YY = expand.grid(XY[,2],XY[,2])#
XX = subset(XX,adjVec==1)#
YY = subset(YY,adjVec==1)#
arrows(x0 = XX[,1],x1=XX[,2],y0 = YY[,1], y1 = YY[,2], length = 0,lwd = 0.1, col = "grey")
quartz(height = 5.5, width = 6)
par(mar=c(5,6,2,1))#
plot(XY[,1],XY[,2],xlab = "X", ylab = "Y",cex.lab = 1.5, cex.axis = 1.25,cex = A, pch = 19)#
adjVec = stack(as.data.frame(adjMat))[,1]#
XX = expand.grid(XY[,1],XY[,1])#
YY = expand.grid(XY[,2],XY[,2])#
XX = subset(XX,adjVec==1)#
YY = subset(YY,adjVec==1)#
arrows(x0 = XX[,1],x1=XX[,2],y0 = YY[,1], y1 = YY[,2], length = 0,lwd = 0.1, col = "grey")
# Create a random metapop structure#
n = 100#
r = 0.2#
XY = cbind(runif(n), runif(n))#
A = rexp(n = n, rate = 1)#
#
distMat = as.matrix(dist(XY, method = 'euclidean', upper = T, diag = T))#
adjMat = matrix(0, nr = n, nc = n)#
adjMat[distMat < r] = 1#
diag(adjMat) = 0
# Plot the random metapop#
quartz(height = 5.5, width = 6)#
par(mar=c(5,6,2,1))#
plot(XY[,1],XY[,2],xlab = "X", ylab = "Y",cex.lab = 1.5, cex.axis = 1.25,cex = A, pch = 19)#
adjVec = stack(as.data.frame(adjMat))[,1]#
XX = expand.grid(XY[,1],XY[,1])#
YY = expand.grid(XY[,2],XY[,2])#
XX = subset(XX,adjVec==1)#
YY = subset(YY,adjVec==1)#
arrows(x0 = XX[,1],x1=XX[,2],y0 = YY[,1], y1 = YY[,2], length = 0,lwd = 0.1, col = "grey")
eq_px = get_px(adjMat,A,b=0,c=0,e=0.1,f=0.5)#
#
RK = rank(eq_px)#
col = heat.colors(n = n)#
vec.col = numeric(n)#
for(i in 1:n) vec.col[i] = col[RK[i]]#
#
points(XY[,1],XY[,2],pch=21,bg=vec.col,cex = A)
# MAIN FUNCTION: #
model1 = function(p,adjMat,A,b,c,e,f) {#
    degree = apply(adjMat,2,sum)#
    adjMatw = adjMat*matrix(degree^-1,nr = n,nc=n, byrow=F) # Weighted connectivity matrix#
    adjMatw[adjMatw=="NaN"] = 0#
    emigr = f*A^b*p # Outgoing propagules#
    ColProbMat = adjMatw*matrix(emigr,nr = n,nc=n, byrow=F) # Pairwise colonization probability#
    noColProbMat = 1 - ColProbMat   # Pairwise probability of no colonization even#
    ColProbVec = 1 - apply(noColProbMat,2,prod) # Cumulative probability of an immigration event taking place#
    px = ColProbVec/(ColProbVec + e/A^c) - p#
    return(px)#
}#
#
get_px = function(adjMat,A,b,c,e,f) {#
    degree = apply(adjMat,2,sum)#
    model2 = function(p) model1(p,adjMat,A,b,c,e,f)#
    Start = numeric(n) + 1 - e/(mean(degree)*mean(A)^(b+c)*f) # Start with the solution of a mean-field metapop model#
    multiroot(model2,start = Start,positive=TRUE)[[1]]#
}#
eq_px = get_px(adjMat,A,b=0,c=0,e=0.1,f=0.5)#
#
RK = rank(eq_px)#
col = heat.colors(n = n)#
vec.col = numeric(n)#
for(i in 1:n) vec.col[i] = col[RK[i]]#
#
points(XY[,1],XY[,2],pch=21,bg=vec.col,cex = A)
